#include <iostream>
#include <fstream>
using namespace std;
//Автор: Моисеенко Сергей ИФСТ-15 Дата: 15.05.2022

struct rle{//Структура для упаковки байтов
    int mas1[50][16];//Массив для количества байт
    int mas2[50][16];//Массив для значения байта
};

void funcompressor(fstream &file,char *arr, int n){//Функция сжатия байтов
	file.open("res.txt",ios::out);//Открытие файла для записи
	char y;//Переменная для сравнения одинаковых байтов
	int k=1;//Количество одинаковых байтов
	if (file){//Условие записи
		cout<<"Сжатые байты: ";
		for (int i=0;i<n;i++){//Цикл записи сжатых байтов
			y=arr[i];//Обновление переменной для сравнения одинаковых байтов
			if (y!=arr[i+1]){//Условие для сравнения одинаковых байтов
				if (k>1){//Условие вывода количества одинаковых байтов
					file<<k;//Запись количества одинаковых байтов
					cout<<k;//Вывод количества одинаковых байтов
					k=1;//Обновление количества одинаковых байтов
				}
				file<<arr[i];//Запись значения байта
				cout<<arr[i];//Вывод значения байта
			}
			else{//Условие для повторяющихся байтов
				k++;//Увеличение количества одинаковых байтов
			}
		}
	}
	file.close();//Закрытие файла
}

void funpackaging(fstream &file,char *arr, rle *arr1, int n){//Функция упаковки
	file.open("packaging.txt",ios::out);//Открытие файла для упаковки
	int s;//Десятичное число
	int y;//Переменная для сравнения одинаковых байтов
	int r=15;//Сдвиг в массиве
	int k=1;//Количество одинаковых байтов
	int t=0;//Сдвиг в структуре
	char e;//Символ
	if (file){//Условие для включённого файла
		for (int i=0;i<n;i++){//Цикл заполнения массива случайными битами
			s=((int)arr[i])-48;//Новое десятичное число
			y=((int)arr[i])-48;//Обновление переменной для сравнения одинаковых байтов
			e=arr[i];
			if (y!=((int)arr[i+1])-48){//Условие для сравнения одинаковых байтов
				while (r!=1){//Цикл перевода в двоичную систему
					if (s>0){//Условие для заполнения непустых битов
						arr1->mas2[t][r]=s%2;//Сохранение остатка
						s/=2;//Переход к следующему биту
					}
					else{//Условие для пустых битов
						arr1->mas2[t][r]=0;//Запись нуля
					}
					r--;//Сдвиг в массиве
				}
				arr1->mas2[t][0]=0;//Запись флага значения байта
				if (e>='0' and e<='9'){
					arr1->mas2[t][1]=0;//Запись флага значения числа
				}
				else{
					arr1->mas2[t][1]=1;//Запись флага значения символа
				}
				r=15;//Обновление сдвига
				arr1->mas1[t][0]=-1;//Запись флага пропуска записи количества байтов
				if (k>1){//Условие вывода количества одинаковых байтов
					while (r!=0){//Цикл перевода в двоичную систему
						if (k>0){//Условие для заполнения непустых битов
							arr1->mas1[t][r]=k%2;//Сохранение остатка
							k/=2;//Переход к следующему биту
						}
						else{//Условие для пустых битов
							arr1->mas1[t][r]=0;//Запись нуля
						}
						r--;//Сдвиг в массиве
					}
					arr1->mas1[t][0]=1;//Запись флага количества байтов
					r=15;//Обновление сдвига
					k=1;//Обновление количества одинаковых байтов
				}
				t++;//Сдвиг в структуре
			}
			else{//Условие для повторяющихся байтов
				k++;//Увеличение количества одинаковых байтов
			}
		}
		for (int i=0;i<t;i++){//Цикл записи упаковки сжатых байтов с их количеством в двоичном коде
			for (int j=0;j<16;j++){
				if (arr1->mas1[i][0]!=-1){//Условие записи количества одинаковых байтов
					file<<arr1->mas1[i][j];//Запись количества одинаковых байтов
				}
			}
			for (int j=0;j<16;j++){//Условие записи значения байта
				file<<arr1->mas2[i][j];//Запись значения байта
			}
		}
	}
	file.close();//Закрытие файла
}

int main()
{
	setlocale( LC_ALL, "Russian");
	fstream file;//Создание заголовочного файла
	char arr[20]={'9','9','9','9','a','a','4','5','6','7','3','3','9','9','b','b','b','0','0','1'};//Случайная последовательность байтов
	int n=20;//Количество байтов
	rle *arr1=new rle[1];//Структура для упаковки байтов
	funpackaging(file,arr,arr1,n);//Функция упаковки
	funcompressor(file,arr,n);//Функция сжатия байтов
}
